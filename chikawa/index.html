<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å‰ä¼Šå¡å“‡å¤§é€ƒäº¡ï¼šæ‰‹æ©Ÿç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* ç¦æ­¢æ²å‹• */
            background-color: #2ecc71;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* é—œéµï¼šç¦æ­¢ç€è¦½å™¨é è¨­è§¸æ§è¡Œç‚º */
            user-select: none; /* ç¦æ­¢é¸å–æ–‡å­— */
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .score-box {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 15px;
            border: 2px solid #fff;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            color: #333;
            font-weight: bold;
            font-size: 18px;
        }
        #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        .panel {
            background: white;
            padding: 30px;
            border-radius: 25px;
            text-align: center;
            width: 80%;
            max-width: 400px;
            border: 6px solid #ffb7c5;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        h1 { margin: 0 0 15px 0; color: #ff6b81; font-size: 24px; }
        p { font-size: 18px; color: #555; margin-bottom: 25px; }
        .btn {
            background: #ff6b81;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 0 #d63031;
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(5px); box-shadow: none; }
        
        /* æ‰‹æ©Ÿæç¤º */
        .mobile-hint {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">
                <div id="score">åˆ†æ•¸: 0</div>
                <div id="level" style="font-size:14px; color:#666;">Lv.1</div>
            </div>
            <div class="score-box" style="background: rgba(255,230,100,0.8);">
                ğŸ† <span id="highscore">0</span>
            </div>
        </div>
        <div class="mobile-hint" id="hint-text">
            é›»è…¦ï¼šWASDç§»å‹•<br>æ‰‹æ©Ÿï¼šä»»æ„è™•æ»‘å‹•æ–æ¡¿
        </div>
    </div>

    <div id="game-over-screen">
        <div class="panel">
            <h1>ğŸ—¿ å·²çŸ³åŒ–</h1>
            <p>å‰ä¼Šå¡å“‡è®ŠæˆçŸ³é ­äº†...</p>
            <p style="font-size: 24px; font-weight: bold; color: #333;">å¾—åˆ†: <span id="final-score">0</span></p>
            <button class="btn" onclick="startGame()">å†é€ƒä¸€æ¬¡!</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // éŠæˆ²å…¨åŸŸè®Šæ•¸
    let gameRunning = false;
    let score = 0;
    let level = 1;
    let frameCount = 0;
    let highScore = localStorage.getItem('chiikawa_run_best') || 0;
    document.getElementById('highscore').innerText = highScore;

    // è¦–çª—èª¿æ•´
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ============================
    // è¼¸å…¥æ§åˆ¶ (éµç›¤ + è™›æ“¬æ–æ¡¿)
    // ============================
    const input = { x: 0, y: 0 }; // æ­£è¦åŒ–çš„ç§»å‹•å‘é‡ (-1 åˆ° 1)
    
    // éµç›¤ç‹€æ…‹
    const keys = { w: false, a: false, s: false, d: false };
    
    window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if ('wasd'.includes(key) || e.key.startsWith('Arrow')) {
            if (key === 'w' || e.key === 'ArrowUp') keys.w = true;
            if (key === 'a' || e.key === 'ArrowLeft') keys.a = true;
            if (key === 's' || e.key === 'ArrowDown') keys.s = true;
            if (key === 'd' || e.key === 'ArrowRight') keys.d = true;
            updateKeyboardInput();
        }
    });

    window.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if ('wasd'.includes(key) || e.key.startsWith('Arrow')) {
            if (key === 'w' || e.key === 'ArrowUp') keys.w = false;
            if (key === 'a' || e.key === 'ArrowLeft') keys.a = false;
            if (key === 's' || e.key === 'ArrowDown') keys.s = false;
            if (key === 'd' || e.key === 'ArrowRight') keys.d = false;
            updateKeyboardInput();
        }
    });

    function updateKeyboardInput() {
        // å¦‚æœæ²’æœ‰è§¸æ§ï¼Œæ‰ç”¨éµç›¤å€¼
        if (!joystick.active) {
            input.x = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
            input.y = (keys.s ? 1 : 0) - (keys.w ? 1 : 0);
            // æ­£è¦åŒ–é¿å…æ–œå‘åŠ é€Ÿ
            const mag = Math.hypot(input.x, input.y);
            if (mag > 1) {
                input.x /= mag;
                input.y /= mag;
            }
        }
    }

    // è™›æ“¬æ–æ¡¿é‚è¼¯
    const joystick = {
        active: false,
        originX: 0,
        originY: 0,
        currentX: 0,
        currentY: 0,
        radius: 50 // æ–æ¡¿åŠå¾‘
    };

    // è§¸æ§äº‹ä»¶
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        joystick.active = true;
        joystick.originX = touch.clientX;
        joystick.originY = touch.clientY;
        joystick.currentX = touch.clientX;
        joystick.currentY = touch.clientY;
        document.getElementById('hint-text').style.display = 'none'; // éš±è—æç¤º
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystick.active) return;
        const touch = e.touches[0];
        joystick.currentX = touch.clientX;
        joystick.currentY = touch.clientY;

        // è¨ˆç®—å‘é‡
        let dx = joystick.currentX - joystick.originX;
        let dy = joystick.currentY - joystick.originY;
        const dist = Math.hypot(dx, dy);

        // é™åˆ¶æ–æ¡¿åœ“çƒåœ¨åŠå¾‘å…§
        if (dist > joystick.radius) {
            const ratio = joystick.radius / dist;
            dx *= ratio;
            dy *= ratio;
            joystick.currentX = joystick.originX + dx;
            joystick.currentY = joystick.originY + dy;
        }

        // æ›´æ–°å…¨åŸŸè¼¸å…¥å‘é‡ (é™¤ä»¥åŠå¾‘å¾—åˆ° 0~1 çš„å€¼)
        input.x = dx / joystick.radius;
        input.y = dy / joystick.radius;
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        joystick.active = false;
        input.x = 0;
        input.y = 0;
    });

    // ============================
    // éŠæˆ²ç‰©ä»¶
    // ============================

    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 25;
            this.maxSpeed = 6;
            this.isStone = false;
            this.angle = 0; // å‚¾æ–œå‹•ç•«ç”¨
            this.bobble = 0; // ä¸Šä¸‹è·³å‹•
        }

        update() {
            if (this.isStone) return;

            // ç§»å‹•
            this.x += input.x * this.maxSpeed;
            this.y += input.y * this.maxSpeed;

            // é‚Šç•Œé™åˆ¶
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

            // å‹•ç•«è¨ˆç®—
            const isMoving = Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1;
            if (isMoving) {
                this.bobble = Math.sin(frameCount * 0.5) * 3;
                // æ ¹æ“šç§»å‹•æ–¹å‘å·¦å³å‚¾æ–œ
                this.angle = input.x * 0.2;
            } else {
                this.bobble = 0;
                this.angle = 0;
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y + this.bobble);
            ctx.rotate(this.angle);

            if (this.isStone) {
                ctx.filter = 'grayscale(100%) contrast(1.2)';
            }

            // èº«é«”
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 22, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#333';
            ctx.stroke();

            // è€³æœµ
            ctx.beginPath();
            ctx.arc(-18, -15, 8, 0, Math.PI * 2); // å·¦
            ctx.arc(18, -15, 8, 0, Math.PI * 2);  // å³
            ctx.fill();
            ctx.stroke();

            // è‡‰éƒ¨
            ctx.fillStyle = '#333';
            if (this.isStone) {
                // çŸ³åŒ–è¡¨æƒ…
                ctx.font = "bold 20px Arial";
                ctx.textAlign = "center";
                ctx.fillText("x  x", 0, 5);
            } else {
                // çœ¼ç›
                ctx.beginPath();
                ctx.arc(-8, -2, 2.5, 0, Math.PI * 2);
                ctx.arc(8, -2, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // è…®ç´…
                ctx.fillStyle = '#ffb7c5';
                ctx.beginPath();
                ctx.arc(-14, 5, 5, 0, Math.PI * 2);
                ctx.arc(14, 5, 5, 0, Math.PI * 2);
                ctx.fill();

                // å˜´å·´
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(0, 2, 3, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // æ·šå¥”ç‰¹æ•ˆ (å¦‚æœç§»å‹•é€Ÿåº¦å¤ å¿«)
                if (Math.abs(input.x) > 0.5 || Math.abs(input.y) > 0.5) {
                    ctx.fillStyle = '#a4b0be'; // æ·šæ°´è‰²
                    ctx.beginPath();
                    ctx.arc(-20, 0 + Math.random()*5, 3, 0, Math.PI*2);
                    ctx.arc(20, 0 + Math.random()*5, 3, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }
    }

    class Snake {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = -50; // å¾ä¸Šé¢é£›ä¸‹ä¾†
            this.angle = 0;
            this.targetX = 0;
            this.targetY = 0;
        }

        update(player) {
            // è›‡æœƒå˜—è©¦ä¿æŒåœ¨ç©å®¶ä¸Šæ–¹çš„ä¸€å®šè·é›¢ï¼Œåƒæ˜¯åœ¨è§€å¯Ÿ
            const hoverDist = 150;
            this.targetX = player.x + Math.sin(frameCount * 0.02) * 100; // å·¦å³å¾˜å¾Š
            this.targetY = player.y - hoverDist;

            // å¹³æ»‘ç§»å‹• (Lerp)
            this.x += (this.targetX - this.x) * 0.05;
            this.y += (this.targetY - this.y) * 0.05;

            // è®“è›‡é ­æœå‘ç©å®¶
            this.angle = Math.atan2(player.y - this.y, player.x - this.x);
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // èº«é«”å…‰æšˆ
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            
            // ç•«è›‡é ­
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(0, 0, 35, 25, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0; // é—œé–‰å…‰æšˆç•«ç·šæ¢
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ddd';
            ctx.stroke();

            // ç´…çœ¼ (å…‡)
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(-12, 5, 4, 0, Math.PI*2); // å·¦çœ¼
            ctx.arc(12, 5, 4, 0, Math.PI*2);  // å³çœ¼
            ctx.fill();

            // ç•«è›‡èº« (ç°¡å–®çš„å°¾å·´æ“ºå‹•)
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.quadraticCurveTo(
                Math.sin(frameCount * 0.2) * 20, -50, 
                Math.sin(frameCount * 0.2) * 10, -70
            );
            ctx.lineWidth = 15;
            ctx.strokeStyle = '#fff';
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y, targetX, targetY) {
            this.x = x;
            this.y = y;
            this.radius = 10;
            // é›£åº¦è¶Šé«˜ï¼Œå­å½ˆè¶Šå¿«
            const speedBase = 4 + (level * 0.5);
            const angle = Math.atan2(targetY - y, targetX - x);
            this.dx = Math.cos(angle) * speedBase;
            this.dy = Math.sin(angle) * speedBase;
            this.life = 0;
        }

        update() {
            this.x += this.dx;
            this.y += this.dy;
            this.life++;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // ç´«è‰²å…‰æ³¢ç‰¹æ•ˆ
            const pulse = Math.sin(frameCount * 0.5) * 5;
            ctx.shadowBlur = 10 + pulse;
            ctx.shadowColor = '#8e44ad';
            
            ctx.fillStyle = '#9b59b6';
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            ctx.fill();
            
            // æ ¸å¿ƒäº®é»
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-2, -2, 3, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }

    // ============================
    // éŠæˆ²ä¸»æµç¨‹
    // ============================
    let player, snake, bullets;
    let gridOffset = { x: 0, y: 0 }; // ç”¨æ–¼èƒŒæ™¯ç§»å‹•æ„Ÿ

    function initGame() {
        player = new Player();
        snake = new Snake();
        bullets = [];
        score = 0;
        level = 1;
        frameCount = 0;
        gameRunning = true;
        document.getElementById('game-over-screen').style.display = 'none';
    }

    function drawBackground() {
        // ç¹ªè£½è‰åœ°èƒŒæ™¯èˆ‡ç¶²æ ¼
        ctx.fillStyle = '#e6f9e6'; // æ·ºè‰ç¶ 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ç°¡å–®ç¶²æ ¼ç·šï¼Œè£½é€ ç§»å‹•æ„Ÿ (å…¶å¯¦æ˜¯ç•«å¸ƒä¸å‹•ï¼Œç¶²æ ¼åœ¨å‹•çš„éŒ¯è¦º)
        // ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œé€™è£¡ä½¿ç”¨å›ºå®šç¶²æ ¼ï¼Œè®“ç©å®¶è¦ºå¾—æ˜¯è‡ªå·±åœ¨å‹•
        ctx.strokeStyle = 'rgba(46, 204, 113, 0.2)';
        ctx.lineWidth = 2;
        const gridSize = 50;
        
        // æ ¹æ“šç©å®¶ä½ç½®è¨ˆç®—ç¶²æ ¼åç§»ï¼Œè£½é€ ç›¸æ©Ÿè·Ÿéš¨æ„Ÿ
        // é€™è£¡åšä¸€å€‹ç°¡å–®çš„è¦–è¦ºæ¬ºé¨™ï¼šç¶²æ ¼éš¨è‘— (-player.x, -player.y) ç§»å‹•
        let shiftX = -player.x % gridSize;
        let shiftY = -player.y % gridSize;

        ctx.beginPath();
        for(let x = shiftX; x < canvas.width; x += gridSize) {
            ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
        }
        for(let y = shiftY; y < canvas.height; y += gridSize) {
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
    }

    function drawJoystick() {
        if (!joystick.active) return;
        
        ctx.save();
        // åº•åº§
        ctx.beginPath();
        ctx.arc(joystick.originX, joystick.originY, joystick.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // æ–æ¡¿é ­
        ctx.beginPath();
        ctx.arc(joystick.currentX, joystick.currentY, 20, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.shadowBlur = 5;
        ctx.shadowColor = 'rgba(0,0,0,0.2)';
        ctx.fill();
        ctx.restore();
    }

    function gameLoop() {
        if (!gameRunning) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawBackground();

        // é‚è¼¯æ›´æ–°
        player.update();
        snake.update(player);

        // åˆ†æ•¸æ©Ÿåˆ¶ï¼šå­˜æ´»æ¯ç§’åŠ åˆ†
        if (frameCount % 60 === 0) {
            score += 10;
            // æ¯ 100 åˆ†å‡ç´š
            if (score % 100 === 0) level++;
        }

        // æ•µäººå°„æ“Š
        // é›£åº¦æ§åˆ¶ï¼šç­‰ç´šè¶Šé«˜ï¼Œå°„æ“Šé–“éš”è¶ŠçŸ­ (æœ€å¿« 20å¹€å°„ä¸€æ¬¡)
        let fireRate = Math.max(20, 90 - (level * 5));
        if (frameCount % fireRate === 0) {
            bullets.push(new Bullet(snake.x, snake.y, player.x, player.y));
            // é«˜ç­‰ç´šæ™‚ç™¼å°„æ•£å°„
            if (level >= 5) {
                let b2 = new Bullet(snake.x, snake.y, player.x + 50, player.y + 50);
                let b3 = new Bullet(snake.x, snake.y, player.x - 50, player.y + 50);
                bullets.push(b2, b3);
            }
        }

        // å­å½ˆè™•ç†
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.update();
            b.draw();

            // ç§»é™¤å‡ºç•Œå­å½ˆ
            if (b.x < -50 || b.x > canvas.width + 50 || b.y < -50 || b.y > canvas.height + 50) {
                bullets.splice(i, 1);
                continue;
            }

            // ç¢°æ’æª¢æ¸¬
            const dist = Math.hypot(b.x - player.x, b.y - player.y);
            if (dist < player.radius + b.radius - 5) {
                endGame();
            }
        }

        player.draw();
        snake.draw();
        drawJoystick();

        // UI æ›´æ–°
        document.getElementById('score').innerText = `åˆ†æ•¸: ${score}`;
        document.getElementById('level').innerText = `Lv.${level}`;

        frameCount++;
        requestAnimationFrame(gameLoop);
    }

    function endGame() {
        gameRunning = false;
        player.isStone = true;
        
        // é‡ç¹ªæœ€å¾Œä¸€å¹€ä»¥é¡¯ç¤ºçŸ³åŒ–
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        for(let b of bullets) b.draw();
        snake.draw();
        player.draw(); // ç•«å‡ºçŸ³åŒ–ç‹€æ…‹

        if (score > highScore) {
            highScore = score;
            localStorage.setItem('chiikawa_run_best', highScore);
            document.getElementById('highscore').innerText = highScore;
        }
        
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function startGame() {
        initGame();
        requestAnimationFrame(gameLoop);
    }

    // é–‹å§‹ç•«é¢
    initGame();
    // é€™è£¡æˆ‘å€‘ç›´æ¥è®“å®ƒè·‘ï¼Œä½†æœ€å¥½æœ‰ä¸€å€‹ã€Œé»æ“Šé–‹å§‹ã€ä¾†è§¸ç™¼éŸ³æ•ˆ(å¦‚æœæœ‰)æˆ–å…¨è¢å¹•
    // ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œç›´æ¥åŸ·è¡Œå¾ªç’°
    gameLoop();

</script>
</body>
</html>
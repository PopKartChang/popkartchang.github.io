<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>東方吉伊卡哇：白蛇異變</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            touch-action: none; /* 禁止瀏覽器預設觸控 */
            user-select: none;
        }

        /* 畫布與容器 */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI 通用樣式 */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* HUD (抬頭顯示器) */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
        }

        .score-board {
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 18px;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 1px 1px 2px black;
        }

        /* 按鈕樣式 (東方風格) */
        .btn-touhou {
            background: linear-gradient(to bottom, #fff, #f0f0f0);
            border: 2px solid #8e44ad;
            border-radius: 8px;
            padding: 15px 40px;
            font-size: 24px;
            color: #8e44ad;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 0 #5e2d73, 0 10px 10px rgba(0,0,0,0.2);
            transition: transform 0.1s;
            pointer-events: auto;
            margin: 10px;
            min-width: 200px;
        }
        .btn-touhou:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #5e2d73, inset 0 2px 5px rgba(0,0,0,0.2);
        }
        .btn-small {
            padding: 8px 15px;
            font-size: 16px;
            min-width: auto;
            background: rgba(255,255,255,0.9);
            border: 2px solid #333;
            color: #333;
            box-shadow: 0 3px 0 #666;
        }

        /* 各個畫面 */
        #start-screen, #game-over-screen, #pause-screen {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        h1 { color: #ffb7c5; font-size: 32px; text-shadow: 2px 2px 0 #fff, 4px 4px 0 #8e44ad; margin-bottom: 30px; text-align: center; }
        .sub-text { color: white; font-size: 16px; margin-bottom: 20px; text-align: center; opacity: 0.9; }

        /* 隱藏 */
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
        <div class="score-board">
            <div>HiScore: <span id="hiscore-val">0</span></div>
            <div>Score: <span id="score-val">0</span></div>
        </div>
        <button id="btn-pause" class="btn-touhou btn-small" style="pointer-events: auto;">暫停 II</button>
    </div>

    <!-- 開始畫面 -->
    <div id="start-screen" class="ui-layer">
        <h1>東方吉伊卡哇<br><span style="font-size:20px; color:white; text-shadow:none;">~ 白蛇異變 ~</span></h1>
        <p class="sub-text">滑動螢幕任意處移動 / 鍵盤方向鍵</p>
        <button class="btn-touhou" onclick="startGame()">開始異變解決</button>
    </div>

    <!-- 暫停畫面 -->
    <div id="pause-screen" class="ui-layer hidden">
        <h1 style="color:white; text-shadow: 2px 2px 0 #333;">暫停中</h1>
        <button class="btn-touhou" onclick="resumeGame()">繼續遊戲</button>
        <button class="btn-touhou" style="font-size: 18px; background: #eee;" onclick="backToMenu()">返回標題</button>
    </div>

    <!-- 遊戲結束畫面 -->
    <div id="game-over-screen" class="ui-layer hidden">
        <h1 style="color: #95a5a6;">滿身瘡痍 (石化)</h1>
        <p class="sub-text" style="font-size: 24px;">最終得分: <span id="final-score">0</span></p>
        <button class="btn-touhou" onclick="startGame()">再次挑戰</button>
        <button class="btn-touhou" style="font-size: 18px; background: #eee;" onclick="backToMenu()">返回標題</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 遊戲狀態枚舉
    const STATE = { MENU: 0, PLAYING: 1, PAUSED: 2, GAMEOVER: 3 };
    let currentState = STATE.MENU;

    // 系統變數
    let score = 0;
    let highScore = localStorage.getItem('chiikawa_touhou_hiscore') || 0;
    let frameCount = 0;
    let bgOffsetY = 0; // 背景捲動用

    // 畫面控制
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 更新 UI 顯示
    document.getElementById('hiscore-val').innerText = highScore;

    function switchScreen(screenId) {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('pause-screen').classList.add('hidden');
        document.getElementById('hud').classList.add('hidden');

        if (screenId) {
            document.getElementById(screenId).classList.remove('hidden');
        }
    }

    // ============================
    // 輸入控制 (觸控 + 鍵盤)
    // ============================
    const input = { dx: 0, dy: 0, active: false };
    let lastTouch = { x: 0, y: 0 };
    
    // 鍵盤狀態
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    // 觸控邏輯 (相對移動)
    canvas.addEventListener('touchstart', (e) => {
        if (currentState !== STATE.PLAYING) return;
        const t = e.touches[0];
        lastTouch.x = t.clientX;
        lastTouch.y = t.clientY;
        input.active = true;
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        if (currentState !== STATE.PLAYING) return;
        e.preventDefault(); // 防止滾動
        const t = e.touches[0];
        
        // 計算變化量
        const deltaX = t.clientX - lastTouch.x;
        const deltaY = t.clientY - lastTouch.y;

        // 更新玩家位置
        player.move(deltaX * 1.5, deltaY * 1.5); // 1.5倍靈敏度

        // 紀錄最後位置
        lastTouch.x = t.clientX;
        lastTouch.y = t.clientY;
    }, {passive: false});

    canvas.addEventListener('touchend', () => { input.active = false; });

    // 鍵盤邏輯
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    // ============================
    // 遊戲物件類別
    // ============================
    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height - 100;
            this.radius = 20; // 視覺半徑
            this.hitbox = 4;  // 實際判定半徑 (東方風格：判定點極小)
            this.speed = 6;
            this.isStone = false;
        }

        move(dx, dy) {
            if (this.isStone) return;
            this.x += dx;
            this.y += dy;
            this.clamp();
        }

        update() {
            if (this.isStone) return;
            // 鍵盤移動處理
            let dx = 0, dy = 0;
            if (keys.ArrowUp) dy = -this.speed;
            if (keys.ArrowDown) dy = this.speed;
            if (keys.ArrowLeft) dx = -this.speed;
            if (keys.ArrowRight) dx = this.speed;
            this.move(dx, dy);
        }

        clamp() {
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);

            if (this.isStone) {
                ctx.filter = 'grayscale(100%) brightness(0.5)';
            }

            // 吉伊卡哇本體 (白色圓球)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            ctx.fill();
            
            // 外框
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 耳朵
            ctx.beginPath();
            ctx.arc(-15, -12, 8, 0, Math.PI*2);
            ctx.arc(15, -12, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();

            // 臉部
            ctx.fillStyle = '#333';
            if (this.isStone) {
                ctx.fillText("x x", -10, 5);
            } else {
                // 眼睛
                ctx.beginPath();
                ctx.arc(-7, -2, 2, 0, Math.PI*2);
                ctx.arc(7, -2, 2, 0, Math.PI*2);
                ctx.fill();
                // 腮紅
                ctx.fillStyle = '#ffb7c5';
                ctx.beginPath();
                ctx.arc(-12, 5, 4, 0, Math.PI*2);
                ctx.arc(12, 5, 4, 0, Math.PI*2);
                ctx.fill();
            }

            // 繪製判定點 (東方風格的核心：紅點)
            if (!this.isStone) {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(0, 0, this.hitbox, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // 判定點周圍的慢速光暈
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(0, 0, this.hitbox + 4 + Math.sin(frameCount * 0.2)*2, 0, Math.PI*2);
                ctx.stroke();
            }

            ctx.restore();
        }
    }

    class Boss {
        constructor() {
            this.x = canvas.width / 2;
            this.y = 100;
            this.targetX = canvas.width / 2;
            this.hp = 100;
        }

        update() {
            // 平滑移動到目標位置
            if (frameCount % 120 === 0) {
                this.targetX = Math.random() * (canvas.width - 100) + 50;
            }
            this.x += (this.targetX - this.x) * 0.05;
            this.y = 80 + Math.sin(frameCount * 0.05) * 10;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);

            // 魔法陣光環 (裝飾)
            ctx.strokeStyle = `hsla(${frameCount % 360}, 70%, 70%, 0.5)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 60, 0, Math.PI*2);
            ctx.stroke();
            
            // 旋轉的第二圈
            ctx.rotate(frameCount * 0.02);
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.arc(0, 0, 70, 0, Math.PI*2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.rotate(-frameCount * 0.02);

            // 白蛇本體
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 30, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ddd';
            ctx.stroke();
            
            // 紅眼
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(-15, -5, 5, 0, Math.PI*2);
            ctx.arc(15, -5, 5, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y, angle, speed, type) {
            this.x = x;
            this.y = y;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.type = type; // 0: 小彈, 1: 大光波
            this.radius = type === 1 ? 12 : 6;
            this.color = type === 1 ? '#9b59b6' : '#a55eea';
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // 光暈
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fillStyle = '#fff'; // 中心亮白

            if (this.type === 1) {
                // 大光波
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI*2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            } else {
                // 米粒彈
                ctx.rotate(Math.atan2(this.vy, this.vx));
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius + 4, this.radius, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius, this.radius-2, 0, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.restore();
        }
    }

    // ============================
    // 遊戲主循環與邏輯
    // ============================
    let player, boss, bullets;

    function initGame() {
        player = new Player();
        boss = new Boss();
        bullets = [];
        score = 0;
        frameCount = 0;
        document.getElementById('score-val').innerText = '0';
    }

    // 彈幕發射邏輯 (東方風格)
    function handleDanmaku() {
        // 難度隨時間增加
        const difficulty = 1 + Math.floor(score / 500) * 0.1;
        
        // 模式 A: 狙擊彈 (每 40 幀)
        if (frameCount % Math.max(20, 40 - Math.floor(score/200)) === 0) {
            const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
            bullets.push(new Bullet(boss.x, boss.y, angle, 4 * difficulty, 1));
            // 隨難度增加發射扇形
            if (score > 500) {
                bullets.push(new Bullet(boss.x, boss.y, angle + 0.3, 4 * difficulty, 1));
                bullets.push(new Bullet(boss.x, boss.y, angle - 0.3, 4 * difficulty, 1));
            }
        }

        // 模式 B: 全方位擴散 (每 100 幀)
        if (frameCount % 100 === 0) {
            const count = 12 + Math.floor(score / 300);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + frameCount * 0.01;
                bullets.push(new Bullet(boss.x, boss.y, angle, 3, 0));
            }
        }

        // 模式 C: 螺旋彈幕 (分數高時出現)
        if (score > 1000 && frameCount % 5 === 0) {
            const angle = frameCount * 0.2;
            bullets.push(new Bullet(boss.x, boss.y, angle, 5, 0));
            bullets.push(new Bullet(boss.x, boss.y, angle + Math.PI, 5, 0));
        }
    }

    function checkCollisions() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            
            // 判定點碰撞 (只計算中心紅點)
            const dist = Math.hypot(b.x - player.x, b.y - player.y);
            // 判定距離 = 子彈半徑 + 玩家判定點半徑 (稍微寬容一點點)
            if (dist < b.radius + player.hitbox - 2) {
                gameOver();
            }

            // 移除出界子彈
            if (b.x < -50 || b.x > canvas.width+50 || b.y < -50 || b.y > canvas.height+50) {
                bullets.splice(i, 1);
            }
        }
    }

    function drawBackground() {
        // 畫一個向下捲動的天空
        bgOffsetY += 2;
        if (bgOffsetY > canvas.height) bgOffsetY = 0;

        // 雲層效果 (簡單示意)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(100, (bgOffsetY + 100) % canvas.height, 50, 0, Math.PI*2);
        ctx.arc(canvas.width - 50, (bgOffsetY + 400) % canvas.height, 80, 0, Math.PI*2);
        ctx.fill();
    }

    function loop() {
        if (currentState !== STATE.PLAYING) return;

        // 邏輯更新
        frameCount++;
        score++;
        document.getElementById('score-val').innerText = score;

        player.update();
        boss.update();
        
        handleDanmaku();
        
        for (let b of bullets) b.update();
        
        checkCollisions();

        // 繪圖
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground(); // 動態背景
        boss.draw();      // Boss 在下層
        for (let b of bullets) b.draw(); // 彈幕
        player.draw();    // 玩家在上層

        requestAnimationFrame(loop);
    }

    // ============================
    // 流程控制函數
    // ============================
    function startGame() {
        initGame();
        currentState = STATE.PLAYING;
        switchScreen('hud');
        loop();
    }

    function pauseGame() {
        if (currentState === STATE.PLAYING) {
            currentState = STATE.PAUSED;
            switchScreen('pause-screen');
        }
    }

    function resumeGame() {
        if (currentState === STATE.PAUSED) {
            currentState = STATE.PLAYING;
            switchScreen('hud');
            loop();
        }
    }

    function backToMenu() {
        currentState = STATE.MENU;
        switchScreen('start-screen');
        // 清空背景
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function gameOver() {
        currentState = STATE.GAMEOVER;
        player.isStone = true;
        
        // 重畫最後一幀顯示石化
        player.draw();
        
        // 更新最高分
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('chiikawa_touhou_hiscore', highScore);
        }
        
        document.getElementById('final-score').innerText = score;
        setTimeout(() => {
            switchScreen('game-over-screen');
        }, 500); // 延遲一下讓玩家看到石化
    }

    // 綁定暫停按鈕
    document.getElementById('btn-pause').addEventListener('click', pauseGame);

    // 初始狀態
    backToMenu();

</script>
</body>
</html>